package compression.grammargenerator;

import compression.Compressions;
import compression.RuleProbType;
import compression.data.Dataset;
import compression.grammar.NonTerminal;
import compression.grammar.RNAGrammar;
import compression.grammar.Rule;
import compression.grammar.SecondaryStructureGrammar;

import java.io.IOException;
import java.io.PrintWriter;
import java.util.Comparator;
import java.util.Objects;
import java.util.SortedSet;

/**
 * @author Sebastian Wild (wild@liverpool.ac.uk)
 */
public class AbstractGrammarExplorer {
	protected final int nNonterminals;
	protected final Rule[] allPossibleRules;
	protected final NonTerminal[] nonTerminals;

	public AbstractGrammarExplorer(final int nNonterminals) {
		this.nNonterminals = nNonterminals;
		nonTerminals = new NonTerminal[nNonterminals];
		allPossibleRules = AutoGeneratedGrammars.generateAllRules(this.nNonterminals).toArray(new Rule[0]);
		for (int i = 0; i < nNonterminals; i++) {
			nonTerminals[i] = new NonTerminal("A" + i);
		}
	}

	protected static void printGrammars(PrintWriter out, final SortedSet<GrammarWithScore> bestGrammars) throws IOException {
		int rank = 1;
		for (GrammarWithScore grammarWithScore : bestGrammars) {
			if (grammarWithScore.grammar == null) continue;
			out.println(rank + "\t" + grammarWithScore.grammar.name);
			out.println("\t" + grammarWithScore);
			out.println();
			rank++;
			// way too much to keep all grammars
			// new GrammarReaderNWriter(folderPath, grammarWithScore.grammar).writeGrammarToFile(grammarWithScore.grammar);
		}
		out.flush();
	}

	public static double getBitsPerBase(final Dataset dataset, final RuleProbType model, final SecondaryStructureGrammar grammar, final boolean withNonCanonicalRules) {
		assert model == RuleProbType.ADAPTIVE || model == RuleProbType.SEMI_ADAPTIVE;
		RNAGrammar rnaGrammar = RNAGrammar.from(grammar, withNonCanonicalRules);
		return Compressions.getBitsPerBase(Compressions.getEncodedLengthsParallel(
				dataset, rnaGrammar, model, null));
	}

	public static class GrammarWithScore implements Comparable<RandomGrammarExplorer.GrammarWithScore> {
		public final SecondaryStructureGrammar grammar;
		public final double avgBitsPerBase;
		public final double avgBitsPerBaseSmallDataset;

		public GrammarWithScore(final SecondaryStructureGrammar grammar, final double avgBitsPerBase, final double avgBitsPerBaseSmallDataset) {
			this.grammar = grammar;
			this.avgBitsPerBase = avgBitsPerBase;
			this.avgBitsPerBaseSmallDataset = avgBitsPerBaseSmallDataset;
		}

		@Override
		public int compareTo(final GrammarWithScore o) {
			int cmp = Double.compare(avgBitsPerBase, o.avgBitsPerBase);
			if (cmp != 0) return cmp;
			if (grammar == null && o.grammar != null) return 1;
			if (grammar != null && o.grammar == null) return -1;
			if (grammar == null && o.grammar == null) return 0;
			return grammar.name.compareTo(o.grammar.name);
		}

		@Override
		public String toString() {
			return "GrammarWithScore(" +
					"grammar=" + grammar +
					", avgBitsPerBase=" + avgBitsPerBase +
					", avgBitsPerBaseSmallDataset=" + avgBitsPerBaseSmallDataset +
					')';
		}
	}
}
