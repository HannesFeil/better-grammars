package compression.grammargenerator;

import compression.LocalConfig;
import compression.data.Dataset;
import compression.grammar.*;
import compression.parser.GrammarReaderNWriter;
import compression.parser.SRFParser;

import static java.util.Comparator.comparing;

import java.io.*;
import java.util.*;

public final class ParsableAutoGenGrammars {

	private final int noOfNonTerminals;

	Dataset dataset;
	Map<Integer, int[]> Ktable = null;
	int maximum_no_of_rules;
	int minimum_no_of_rules;
	boolean storeFailedGrammars;

	boolean storeGoodGrammars;

	File grammars_that_parse;
	File grammars_that_fail;

	public ParsableAutoGenGrammars(int noOfNonTerminals, Dataset dataset,
	                               File grammars_that_parse, File grammars_that_fail,
	                               int minimum_no_of_rules, int maximum_no_of_rules,
	                               boolean storeFailedGrammars, boolean storeGoodGrammars) {
		this.noOfNonTerminals = noOfNonTerminals;
		this.dataset = dataset;
		this.maximum_no_of_rules = maximum_no_of_rules;
		this.minimum_no_of_rules = minimum_no_of_rules;
		this.grammars_that_parse = grammars_that_parse;
		this.grammars_that_fail = grammars_that_fail;
		this.storeFailedGrammars = storeFailedGrammars;
		this.storeGoodGrammars = storeGoodGrammars;
	}


	public void printKTable() {
		System.out.println("K\t\tParsable\t\tNonParsable");
		for (int i : Ktable.keySet()) {
			System.out.println(i + "\t\t" + Ktable.get(i)[0] + "\t\t" + Ktable.get(i)[1]);
		}

	}

	public List<SecondaryStructureGrammar> getParsableGrammars() throws IOException {
		Map<Integer, int[]> k_table = new HashMap<>();
		List<SecondaryStructureGrammar> G = new ArrayList<>();
		List<Rule> allRules = AutoGeneratedGrammars.generateAllRules(this.noOfNonTerminals);
		int noOfRules = allRules.size();
		System.out.println(allRules);
		if (maximum_no_of_rules == 0 || maximum_no_of_rules < 3) {
			maximum_no_of_rules = noOfRules;
		}
		if (minimum_no_of_rules == 0) {
			minimum_no_of_rules = 3;//starts from k=3 is the minimum possible rules in a grammar, I think
		}


		for (int k = minimum_no_of_rules; k <= maximum_no_of_rules; k++) {
			int grammarIndex = 0;

			//file to keep record of generated rules
			BufferedWriter bf = new BufferedWriter(new FileWriter(LocalConfig.GIT_ROOT + "/grammars/" + k + "-rules-generated-grammars-log.txt"));
			int parsable = 0;
			int notParsable = 0;

			SubsetIterator SSI = new SubsetIterator(noOfRules, k);//get subsets

			while (SSI.hasNext()) {
				int[] s = SSI.next();
				grammarIndex++;

				List<Rule> rules = new ArrayList<>();
				for (int i : s) {
					rules.add(allRules.get(i));
				}
				List<NonTerminal> nonterminals = getLHSNonTerminals(rules);
				NonTerminal startTerminal = nonterminals.get(nonterminals.size() - 1);

				Grammar.Builder<Character> GB = new Grammar.Builder<>(
						"grammar-" + (noOfNonTerminals) + "NTs-" + k + "rules-" + grammarIndex, startTerminal);
				for (int i : s) {
					GB.addRule(allRules.get(i));
				}
				SecondaryStructureGrammar testGrammar = SecondaryStructureGrammar.fromCheap(GB.build());

				if (containsOnlyUsableRules(rules, testGrammar.startSymbol) && noRulesWithEndlessRecursion(rules) && parsable(testGrammar)) {
					parsable++;
					if (storeGoodGrammars) {
						GrammarReaderNWriter parsableWriter = new GrammarReaderNWriter(grammars_that_parse, testGrammar);
						parsableWriter.writeGrammarToFile(testGrammar);
					}
					G.add(testGrammar);
				} else {
					if (storeFailedGrammars) {
						notParsable++;
						GrammarReaderNWriter writeGrammar = new GrammarReaderNWriter(grammars_that_fail, testGrammar);
						writeGrammar.writeGrammarToFile(testGrammar);
					}

				}
			}
			k_table.put(k, new int[]{parsable, notParsable});
			bf.write("All grammars with-" + k + " rules have been generated and written to file!");
			bf.newLine();
			bf.close();
		}
		Ktable = k_table;
		return G;
	}



	public boolean noRulesWithEndlessRecursion(List<Rule> rules) {
		int countRecursion = 0;
		boolean noRecursion = true;

		for (Rule rule : rules) {
			for (Category c : rule.right)
				if (!Category.isTerminal(c)) {
					List<Rule> newRules = new ArrayList<>(rules);
					newRules.remove(rule);
					noRecursion = noRecursion && findTerminal((NonTerminal) c, newRules, countRecursion);
				}
		}
		return noRecursion;
	}

	public boolean findTerminal(NonTerminal nt, List<Rule> r, int counter) {
		counter++;
		for (Rule rule : r) {
			for (Category c : rule.right) {

				if (!Category.isTerminal(c) && counter < r.size()) {
					r.remove(rule);
					return findTerminal((NonTerminal) c, r, counter);
				} else {
					if (Category.isTerminal(c))
						return true;
				}
			}
		}
		return false;
	}

	public boolean containsOnlyUsableRules(List<Rule> rules, NonTerminal startSym) {
		List<NonTerminal> Lhs = new ArrayList<>();
		List<Category> Rhs = new ArrayList<>();
		for (Rule rule : rules) {
			if (!Lhs.contains(rule.left))
				Lhs.add(rule.left);
			for (Category c : rule.right) {
				if (!Rhs.contains(c))
					Rhs.add(c);
			}
		}
		for (NonTerminal nt : Lhs) {
			if (nt != startSym && !Rhs.contains(nt))//checks if some rules are not usable
				return false;
		}
		for (Category c : Rhs)
			if (!Category.isTerminal(c))
				if (!Lhs.contains((NonTerminal) c))
					return false;

		return true;
	}

	public boolean parsable(SecondaryStructureGrammar gr) {
		SRFParser<Character> testingSRFParser = new SRFParser<>(gr);

		for (RNAWithStructure rna : dataset) {
			List<Terminal<Character>> ss = rna.secondaryStructureAsTerminals();
			if (ss.isEmpty()) return false;
			if (!testingSRFParser.parsable(ss)) return false;
		}
		return true;
	}

	private List<NonTerminal> getLHSNonTerminals(List<Rule> rules) {
		List<NonTerminal> nonTerminals = new ArrayList<>();
		for (Rule rule : rules) {
			if (!nonTerminals.contains(rule.left))
				nonTerminals.add(rule.left);
		}
		nonTerminals.sort(comparing(o -> o.name));
		return nonTerminals;
	}
}
