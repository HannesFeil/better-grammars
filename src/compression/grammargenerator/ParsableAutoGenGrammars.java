package compression.grammargenerator;

import compression.LocalConfig;
import compression.data.Dataset;
import compression.grammar.*;
import compression.parser.GrammarReaderNWriter;
import compression.parser.SRFParser;

import static java.util.Comparator.comparing;

import java.io.*;
import java.util.*;

public class ParsableAutoGenGrammars extends AutoGeneratedGrammars {

    Dataset dataset;
    Map<Integer,int[]> Ktable=null;
    int Maximum_no_of_rules=0;
    int Minimum_no_of_rules=0;
    boolean printFailed= false;

    boolean printGood= false;

    File Grammars_that_parse=null;
    File Grammars_that_fail=null;

    public ParsableAutoGenGrammars(int no_Of_Terminals, Dataset dataset, File grammars_that_parse, File grammars_that_fail, int minimum_no_of_rules, int maximum_no_of_rules, boolean printFailedGrammars, boolean printGoodGrammars) {
        super(no_Of_Terminals);
        this.dataset = dataset;
        Maximum_no_of_rules=maximum_no_of_rules;
        Minimum_no_of_rules=minimum_no_of_rules;
        Grammars_that_parse=grammars_that_parse;
        Grammars_that_fail=grammars_that_fail;
        printFailed=printFailedGrammars;
        printGood=printGoodGrammars;
    }

    public ParsableAutoGenGrammars(int no_Of_Terminals, Dataset dataset){
        super(no_Of_Terminals);
        this.dataset = dataset;

    }




    public void printKTable(){
        System.out.println("K\t\tParsable\t\tNonParsable");
        for (int i: Ktable.keySet())
        {
            System.out.println(i+"\t\t"+Ktable.get(i)[0]+"\t\t"+Ktable.get(i)[1]);
        }

    }
    public List<SecondaryStructureGrammar> getParsableGrammars() throws IOException {

        Map<Integer,int[]> k_table = new HashMap<>();

        List<SecondaryStructureGrammar> G = new ArrayList<>();

        Map<Integer, Rule> integerRuleMap = new HashMap<>();

        int grammarIndex = 0; // TODO move into loop

        integerRuleMap = super.generateRules();

        int noOfRules = integerRuleMap.size();
        System.out.println(integerRuleMap);
        if(Maximum_no_of_rules==0 || Maximum_no_of_rules<3){
            Maximum_no_of_rules=noOfRules;
        }
        if (Minimum_no_of_rules==0){
            Minimum_no_of_rules=3;//starts from k=3 is the minimum possible rules in a grammar, I think
        }


        for (int k = Minimum_no_of_rules; k <= Maximum_no_of_rules; k++) {
            //file to keep record of generated rules
            BufferedWriter bf = new BufferedWriter(new FileWriter(LocalConfig.GIT_ROOT+"/grammars/"+k+"-rules-generated-grammars-log.txt"));
            int parsable=0;
            int notParsable=0;

            SubsetIterator SSI = new SubsetIterator(noOfRules, k);//get subsets



            while (SSI.hasNext()) {

                List<Rule> listOfRules = new ArrayList<>();

                //******REMEMBER TO RETURN CODE TO ORIGINAL FORM AFTER CURRENT RUN

                int[] s= SSI.next();
                grammarIndex++;


                for (int i : s) {
                    listOfRules.add(integerRuleMap.get(i));
                }
                List<NonTerminal> listOfLHSNonTerminals = getLHSNonTerminals(listOfRules);

                Collections.sort(listOfLHSNonTerminals, new Comparator<NonTerminal>() {
                    @Override
                    public int compare(NonTerminal o1, NonTerminal o2) {
                        if (o1.name.compareTo(o2.name) > 0) {
                            return 1;
                        } else return -1;
                    }
                });

                System.out.println("List of non Terminals " + listOfLHSNonTerminals);
                NonTerminal startTerminal = listOfLHSNonTerminals.get(listOfLHSNonTerminals.size() - 1);

                //for (NonTerminal nonT : listOfLHSNonTerminals) {


                Grammar.Builder<Character> GB = new Grammar.Builder<>(
                        "grammar-" + (noOfNonTerminals)+"NTs-"+k+"rules-"+grammarIndex, startTerminal);

                //grammarIndex++;

                for (int i : s) {
                    GB.addRule(integerRuleMap.get(i));
                }


                SecondaryStructureGrammar testGrammar = SecondaryStructureGrammar.fromCheap(GB.build());
                System.out.println("testGrammar = " + testGrammar);

                if (testGrammar != null && containsOnlyUsableRules(listOfRules, testGrammar.startSymbol)
                        && noRulesWithEndlessRecursion(listOfRules) && parsable(testGrammar)) {

                    parsable++;
                    if(printGood) {
                        GrammarReaderNWriter parsableWriter = new GrammarReaderNWriter(Grammars_that_parse, testGrammar);
                        parsableWriter.writeGrammarToFile(testGrammar);
                    }
                    G.add(testGrammar);
                } else {
                    if(printFailed) {
                        notParsable++;
                        GrammarReaderNWriter writeGrammar = new GrammarReaderNWriter(Grammars_that_fail, testGrammar);
                        writeGrammar.writeGrammarToFile(testGrammar);
                    }

                }
            }
            k_table.put(k, new int []{parsable,notParsable});
            bf.write("All grammars with-"+k+" rules have been generated and written to file!");
            bf.newLine();
            bf.close();
        }
        Ktable=k_table;
        return G;
    }

//    public boolean noRulesWithUnusedRules(List<Rule> rules){}


    public boolean noRulesWithEndlessRecursion(List<Rule> rules) {
        int max = rules.size();
        int countRecursion = 0;
        boolean noRecursion = true;

        for (Rule rule : rules) {
            NonTerminal startLHS = rule.left;
            for (Category c : rule.right)
                if (!Category.isTerminal(c)) {
                    List<Rule> newRules = new ArrayList<>(rules);
                    boolean ruleTakenOut = newRules.remove(rule);
                    noRecursion = noRecursion && findTerminal((NonTerminal) c, newRules, countRecursion);
                }

        }

        return noRecursion;
    }

    public boolean findTerminal(NonTerminal nt, List<Rule> r, int counter) {
        counter++;
        for (Rule rule : r) {
            NonTerminal startLHS = rule.left;
            for (Category c : rule.right) {

                if (!Category.isTerminal(c) && counter < r.size()) {
                    boolean newRule = r.remove(rule);
                    return findTerminal((NonTerminal) c, r, counter);
                } else {
                    if (Category.isTerminal(c))
                        return true;
                }
            }

        }
        return false;
    }

    public boolean containsOnlyUsableRules(List<Rule> rules, NonTerminal startSym) {
        List<NonTerminal> Lhs = new ArrayList<>();
        List<Category> Rhs = new ArrayList<>();
        for (Rule rule : rules) {
            if (!Lhs.contains(rule.left))
                Lhs.add(rule.left);
            for (Category c : rule.right) {
                if (!Rhs.contains(c))
                    Rhs.add(c);
            }
        }
        for (NonTerminal nt : Lhs) {
            if (nt != startSym && !Rhs.contains(nt))//checks if some rules are not usable
                return false;
        }
        for (Category c : Rhs)
            if (!Category.isTerminal(c))
                if (!Lhs.contains((NonTerminal) c))
                    return false;

        return true;
    }

    public boolean parsable(SecondaryStructureGrammar gr) {
        SRFParser<Character> testingSRFParser = new SRFParser<>(gr);

        for (RNAWithStructure rna : dataset) {
            List<Terminal<Character>> ss = rna.secondaryStructureAsTerminals();
            if (ss.isEmpty()) return false;
            if (!testingSRFParser.parsable(ss)) return false;
        }
        return true;
    }

    private List<NonTerminal> getLHSNonTerminals(List<Rule> rules) {
        List<NonTerminal> nonTerminals = new ArrayList<>();
        for (Rule rule : rules) {
            if (!nonTerminals.contains(rule.left))
                nonTerminals.add(rule.left);

        }
        return nonTerminals;
    }
}
