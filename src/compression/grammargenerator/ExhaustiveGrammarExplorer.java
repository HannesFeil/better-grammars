package compression.grammargenerator;

import compression.LocalConfig;
import compression.RuleProbType;
import compression.data.CachedDataset;
import compression.data.Dataset;
import compression.data.FolderBasedDataset;
import compression.grammar.*;
import compression.parser.GrammarReaderNWriter;
import compression.parser.SRFParser;
import compression.util.MyMultimap;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.*;

/**
 * @author Sebastian Wild (wild@liverpool.ac.uk)
 */
public class ExhaustiveGrammarExplorer extends AbstractGrammarExplorer {
	public static void main(String[] args) throws IOException {
		if (args.length < 4) {
			System.out.println("Usage: ExhaustiveGrammarExplorer #nonterminals #rules keepBestK full-dataset [small-dataset] [rule-prob-model]");
			System.out.println("\t Generate all grammars with #nonterminals and #rules and keep " +
					"the best K grammars according to their compression performance on full-dataset.");
			System.out.println("\t #nonterminals: number of nonterminals in the SRF grammar");
			System.out.println("\t #rules: number of rules in grammar");
			System.out.println("\t keepBestK: number of best grammars to keep or 'inf' to keep all");
			System.out.println("\t full-dataset: folder with RNA files");
			System.out.println("\t small-dataset: folder with RNA files; default: small-dataset");
			System.out.println("\t rule-prob-model: one of 'static', 'semi-adaptive', 'adaptive'; default: adaptive ");
			System.exit(1);
		}
		int nNonterminals = Integer.parseInt(args[0]);
		int nRules = Integer.parseInt(args[1]);
		int nBestToKeep = args[2].equalsIgnoreCase("inf") ?
				Integer.MAX_VALUE : Integer.parseInt(args[2]);
		Dataset fullDataset = new CachedDataset(new FolderBasedDataset(args[3]));
		Dataset smallDataset = new CachedDataset(new FolderBasedDataset(args.length > 5 ? args[4] : "small-dataset"));
		Dataset parsableDataset = new CachedDataset(new FolderBasedDataset("minimal-parsable"));
		System.out.println("noOfTerminals = " + nNonterminals);
		System.out.println("nBestToKeep = " + nBestToKeep);
		System.out.println("fullDataset = " + fullDataset);
		System.out.println("smallDataset = " + smallDataset);
		System.out.println("parsableDataset = " + parsableDataset);
		RuleProbType model = args.length > 5 ? RuleProbType.fromString(args[5]) : RuleProbType.ADAPTIVE;
		System.out.println("rule prob model type = " + model);
		if (model == RuleProbType.STATIC) {
			// generalizing this would not be hard, but have to specify a training dataset then ...
			System.out.println("Only adaptive / semi-adaptive rule probability model is supported at the moment. Sorry.");
			System.exit(1);
		}
		String prefix = (nBestToKeep == Integer.MAX_VALUE ? "all-" : "best-" + nBestToKeep + "-")
				+ nNonterminals + "NTs-" + nRules + "rules-"
				+ model + "-model-" + fullDataset.getName();
		File grammarsFolder = new File(LocalConfig.GIT_ROOT + "/grammars", prefix);
		File logFile = new File(prefix + ".txt");
		System.out.println("Storing grammars in folder " + grammarsFolder);
		grammarsFolder.mkdir();


		ExhaustiveGrammarExplorer explorer = new ExhaustiveGrammarExplorer(nNonterminals);
		if (nRules > explorer.allPossibleRules.length) {
			System.out.println("Cannot generate grammars with " + nRules + " rules; only " + explorer.allPossibleRules.length + " possible rules.");
			System.exit(1);
		}
		explorer.startExploration(nNonterminals, nRules, nBestToKeep,
				fullDataset, smallDataset, parsableDataset, model, grammarsFolder, logFile);

	}

	public void startExploration(int numOfNonterminals, int numOfRules, int nBestGrammarsToKeep, Dataset fullDataset,
	                             Dataset smallDataset, Dataset parsableDataset, RuleProbType model, final File grammarsFolder, final File logFile) throws IOException {
		System.out.println("Intermediate results logged to " + logFile.getAbsolutePath());

		SortedSet<GrammarWithScore> bestGrammars = new TreeSet<>();
		bestGrammars.add(new GrammarWithScore(null, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY));

		// Cache minimal-parsable dataset for performance
		List<List<Terminal<Character>>> parsableDatasetWords = new ArrayList<>(parsableDataset.getSize());
		for (RNAWithStructure rna : parsableDataset) {
			List<Terminal<Character>> terminals = rna.secondaryStructureAsTerminals();
			parsableDatasetWords.add(terminals);
		}

		long nGrammars = 0;
		long nPassedLevel1 = 0, nPassedLevel2 = 0, nPassedLevel3 = 0;

		long startTime = System.currentTimeMillis();
		//while(noOfNonTerminals<=endNoOfNonTerminals){

		List<Rule> allRules = AutoGeneratedGrammars.generateAllRules(numOfNonterminals);
		int totalNumberOfRules = allRules.size();


		SubsetIterator SSI = new SubsetIterator(totalNumberOfRules, numOfRules);//get subsets

		next_grammar:
		while (SSI.hasNext()) {
			nGrammars++;
			String name = "grammar-" + (numOfNonterminals) + "NTs-" + numOfRules + "rules-" + (nGrammars-1);
			SecondaryStructureGrammar ssg = null;
			try {
				ssg = grammarFor(SSI.next(), name);
				// Level 1 check: parses minimal-parsable?
				SRFParser<Character> ssParser = new SRFParser<>(ssg);
				for (List<Terminal<Character>> word : parsableDatasetWords) {
					if (!ssParser.parsable(word))
						continue next_grammar; // ignore this grammar
				}
				// Passed level 1
				System.out.println("Grammar passed level 1 (" + (System.currentTimeMillis() - startTime) + " ms)");
				System.out.println("grammar = " + ssg);
				++nPassedLevel1;
				System.out.println("nPassedLevel1 = " + nPassedLevel1);


				// Level 2: determine bits per base compression ratio on small dataset
				double avgBitsPerBaseSmallDataset = getBitsPerBase(smallDataset, model, ssg, false);
				// if good enough, keep it and go to level 3
				if (bestGrammars.last().avgBitsPerBaseSmallDataset <= avgBitsPerBaseSmallDataset) {
					// ignore this grammar
					continue;
				}
				System.out.println("\tGrammar " + (nGrammars) + " passed level 2 (" + (System.currentTimeMillis() - startTime) + " ms)");
				++nPassedLevel2;

				// Level 3: determine bits per base compression ratio on full dataset
				double avgBitsPerBaseFullDataset = getBitsPerBase(fullDataset, model, ssg, true);
				GrammarWithScore e = new GrammarWithScore(ssg, avgBitsPerBaseFullDataset, avgBitsPerBaseSmallDataset);
				bestGrammars.add(e);
				System.out.println("\tGrammar " + (nGrammars) + " passed level 3  (" + (System.currentTimeMillis() - startTime) + " ms)");
				++nPassedLevel3;
				System.out.println("\tnew entry: " + e);
				if (bestGrammars.size() > nBestGrammarsToKeep) {
					bestGrammars.remove(bestGrammars.last());
				}
				try (PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(logFile)))) {
					out.println("checked grammars = " + nGrammars);
					out.println("nPassedLevel1 = " + nPassedLevel1);
					out.println("nPassedLevel2 = " + nPassedLevel2);
					out.println("nPassedLevel3 = " + nPassedLevel3);
					printGrammars(out, bestGrammars);
				} catch (IOException e1) {
					e1.printStackTrace();
				}
//				System.out.println("Best grammars so far:");
//				printGrammars(new PrintWriter(System.out), bestGrammars);
			} catch (IllegalArgumentException e) {
				// startnonterminal not in rules -> invalid grammar. Safe to ignore
			} catch (Exception e) {
				System.err.println("Didn't expect this: " + e);
				System.err.println(ssg);
				e.printStackTrace();
				System.out.println("Continue with next grammar.");
			}
		}

		try (PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(logFile)))) {
			out.println("checked grammars = " + nGrammars);
			out.println("nPassedLevel1 = " + nPassedLevel1);
			out.println("nPassedLevel2 = " + nPassedLevel2);
			out.println("nPassedLevel3 = " + nPassedLevel3);
			printGrammars(out, bestGrammars);
		} catch (IOException e1) {
			e1.printStackTrace();
		}

		System.out.println("checked grammars = " + nGrammars);
		System.out.println("nPassedLevel1 = " + nPassedLevel1);
		System.out.println("nPassedLevel2 = " + nPassedLevel2);
		System.out.println("nPassedLevel3 = " + nPassedLevel3);

		if (nPassedLevel3 > 0) {
			System.out.println("Best grammars:");
			printGrammars(new PrintWriter(System.out), bestGrammars);
			saveBestGrammars(bestGrammars, grammarsFolder);
		} else {
			System.out.println("No grammars passed level 3.");
			System.out.println("Deleting folder " + grammarsFolder.getAbsolutePath());
			grammarsFolder.delete();
		}
	}

	public void saveBestGrammars(SortedSet<GrammarWithScore> best, File grammarsFolder) throws IOException {
		for (GrammarWithScore g : best) {
			if (g.grammar == null) continue;
			new GrammarReaderNWriter(grammarsFolder, g.grammar).writeGrammarToFile(g.grammar);
		}
	}

	public ExhaustiveGrammarExplorer(final int nNonterminals) {
		super(nNonterminals);
	}

	public SecondaryStructureGrammar grammarFor(int[] usedRules, String name) {
		MyMultimap<NonTerminal, Rule> rules = new MyMultimap<>();
		for (int usedRule : usedRules) {
			Rule rule = allPossibleRules[usedRule];
			rules.put(rule.left, rule);
		}
		NonTerminal startSymbol = nonTerminals[nNonterminals - 1];
		return new SecondaryStructureGrammar(name, startSymbol, rules);
	}

}
